import tops.solvers as dps_sol
import threading
import numpy as np


class Simulator:
    def __init__(self, ps, dt=5e-3, solver=dps_sol.ModifiedEulerDAE, t_end=np.inf, log_fun=None, ode_fun=None):

        self._stopped = False
        self.n_markers = 20
        self.t_end = t_end
        self.dt = dt
        self.log_fun = log_fun
        self.log = callable(self.log_fun)
        self.ps = ps

        if callable(ode_fun):
            self.ode_fun = ode_fun
        else:
            self.ode_fun = self.ps.ode_fun

        self.sol = solver(self.ps.state_derivatives, self.ps.solve_algebraic, 0, self.ps.x0, max_step=self.dt, first_step=self.dt)

        self.new_data_cv = threading.Condition()
        self.new_data_ready = False
        self.x = self.sol.y
        self.t = self.sol.t

        self.interface_functions = dict()
        self.interface_functions_lock = threading.Lock()
        self.interface_timers = dict()


    def stopped(self):
        return self._stopped

    def make_simulation_step(self):
        # Simulate next step
            with self.new_data_cv:
                self.sol.step()

                with self.interface_functions_lock:
                    for key, fun in self.interface_functions.items():
                        fun(self)

                self.new_data_ready = True
                self.new_data_cv.notify()
    
    def main_loop(self):
        t = self.sol.t
        while not self.stopped() and t < self.t_end:
            self.make_simulation_step()
            t = self.sol.t


class InterfacerDirect:
    def __init__(self, rts=None, name='InterfacerDirect'):
        if rts:
            self.connect(rts)

        self.interface_name = name
        self.fs = None
        if self.fs:
            self._timer = 0

    def connect(self, rts):
        rts.interface_functions[self.interface_name] = self.interface_fun

    def interface_fun(self, rts):
        if self.fs:
            if rts.sol.t < self._timer:
                return
            else:
                self._timer += 1 / self.fs

        self.update(self.read_input_signal(rts))
        self.apply_ctrl_signal(rts, self.generate_ctrl_signal())

    def read_input_signal(self, rts):
        # Read input from RealTimeSimulator
        pass

    def apply_ctrl_signal(self, rts, ctrl_signal):
        # Apply control in RealTimeSimulator, generated by "generate_ctrl_signal"
        pass

    def generate_ctrl_signal(self):
        # Generate control signal from internal states
        pass

    def update(self, input):
        # Update internal states from whatever is returned by "read_input_signal"
        pass